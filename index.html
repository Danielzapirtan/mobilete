<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Room Layout Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        #xr-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }

        #xr-button:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #ui-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            display: none;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            opacity: 0.8;
        }

        select, button {
            width: 200px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #444;
            background: #333;
            color: white;
        }

        button {
            background: #4CAF50;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #45a049;
        }

        #status {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            display: none;
            z-index: 99;
        }

        #results {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 100;
        }

        #results h3 {
            margin-bottom: 15px;
            color: #4CAF50;
        }

        #json-output {
            background: #222;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
        }

        #export-btn {
            margin-top: 10px;
            width: 100%;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .scan-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4CAF50;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }

        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            max-width: 500px;
            padding: 30px;
            background: rgba(0,0,0,0.9);
            border-radius: 15px;
            display: block;
            z-index: 101;
        }

        #instructions h2 {
            margin-bottom: 20px;
            color: #4CAF50;
        }

        #instructions p {
            margin-bottom: 15px;
            line-height: 1.5;
        }

        #instructions ol {
            text-align: left;
            margin: 20px;
            line-height: 1.8;
        }

        #start-btn {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Instructions Modal -->
    <div id="instructions">
        <h2>WebXR Room Scanner</h2>
        <p>Scan your room and export the layout as JSON.</p>
        <p><strong>Requirements:</strong></p>
        <ol>
            <li>Modern smartphone with AR capabilities</li>
            <li>Chrome or Safari browser</li>
            <li>Good lighting conditions</li>
            <li>Move slowly around the room</li>
        </ol>
        <p><em>The app will detect walls, floor, and ceiling, then remove furniture automatically.</em></p>
        <button id="start-btn">Start Scanning</button>
    </div>

    <!-- Main UI -->
    <div id="ui-container">
        <div class="control-group">
            <label>Scan Mode:</label>
            <select id="scan-mode">
                <option value="auto">Auto-detect Surfaces</option>
                <option value="manual">Manual Point Selection</option>
            </select>
        </div>
        <div class="control-group">
            <button id="capture-btn">Capture Surface Point</button>
        </div>
        <div class="control-group">
            <button id="process-btn">Process Room Layout</button>
        </div>
        <div class="control-group">
            <button id="reset-btn">Reset Scan</button>
        </div>
    </div>

    <!-- Status Display -->
    <div id="status">Ready to scan...</div>

    <!-- Results Panel -->
    <div id="results">
        <h3>Room Layout JSON</h3>
        <div id="json-output"></div>
        <button id="export-btn">Export JSON File</button>
        <button id="close-results">Close</button>
    </div>

    <!-- Loading Indicator -->
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Processing...</div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- XR Button -->
    <button id="xr-button">Enter AR Mode</button>

    <!-- Three.js and WebXR Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        class RoomScanner {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.xrSession = null;
                this.xrReferenceSpace = null;
                this.hitTestSource = null;
                
                this.scanPoints = [];
                this.detectedSurfaces = [];
                this.roomLayout = null;
                
                this.isScanning = false;
                this.scanMode = 'auto';
                
                this.init();
            }

            async init() {
                // Check for WebXR support
                if (!navigator.xr) {
                    this.showError('WebXR not supported in this browser. Try Chrome on Android or Safari on iOS.');
                    return;
                }

                // Initialize Three.js
                this.setupThreeJS();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Check AR availability
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    this.showError('AR not supported on this device.');
                    return;
                }

                document.getElementById('xr-button').style.display = 'block';
                this.updateStatus('Ready to start AR scanning');
            }

            setupThreeJS() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.xr.enabled = true;
                
                // Add canvas to container
                const container = document.getElementById('canvas-container');
                container.appendChild(this.renderer.domElement);
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 1, 0);
                this.scene.add(directionalLight);
                
                // Add grid helper
                const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
                gridHelper.position.y = -1;
                this.scene.add(gridHelper);
            }

            setupEventListeners() {
                // UI Controls
                document.getElementById('start-btn').addEventListener('click', () => {
                    document.getElementById('instructions').classList.add('hidden');
                    this.startXR();
                });
                
                document.getElementById('xr-button').addEventListener('click', () => this.startXR());
                document.getElementById('capture-btn').addEventListener('click', () => this.capturePoint());
                document.getElementById('process-btn').addEventListener('click', () => this.processRoomLayout());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetScan());
                document.getElementById('export-btn').addEventListener('click', () => this.exportJSON());
                document.getElementById('close-results').addEventListener('click', () => {
                    document.getElementById('results').style.display = 'none';
                });
                
                document.getElementById('scan-mode').addEventListener('change', (e) => {
                    this.scanMode = e.target.value;
                });
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Handle tap for point capture in AR
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (this.xrSession && this.scanMode === 'manual') {
                        this.handleTap(e);
                    }
                });
            }

            async startXR() {
                try {
                    // Request AR session
                    this.xrSession = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['hit-test', 'local'],
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.body }
                    });
                    
                    // Setup XR session
                    this.renderer.xr.setSession(this.xrSession);
                    
                    // Create reference space
                    this.xrReferenceSpace = await this.xrSession.requestReferenceSpace('local');
                    
                    // Initialize hit test source
                    const viewerSpace = await this.xrSession.requestReferenceSpace('viewer');
                    this.hitTestSource = await this.xrSession.requestHitTestSource({ 
                        space: viewerSpace 
                    });
                    
                    // Setup UI for scanning
                    document.getElementById('ui-container').style.display = 'block';
                    document.getElementById('xr-button').style.display = 'none';
                    document.getElementById('status').style.display = 'block';
                    
                    this.isScanning = true;
                    this.updateStatus('Scanning started. Move your phone around the room.');
                    
                    // Start animation loop
                    this.renderer.setAnimationLoop((time, frame) => this.renderScene(time, frame));
                    
                    // Handle session end
                    this.xrSession.addEventListener('end', () => this.onSessionEnd());
                    
                } catch (error) {
                    console.error('Failed to start AR session:', error);
                    this.showError('Failed to start AR: ' + error.message);
                }
            }

            async renderScene(time, frame) {
                if (!this.xrSession) return;
                
                // Get XR frame
                const session = this.renderer.xr.getSession();
                const referenceSpace = this.renderer.xr.getReferenceSpace();
                
                if (frame && this.hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                    
                    if (hitTestResults.length > 0 && this.scanMode === 'auto') {
                        // Auto-detect surfaces
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        
                        // Classify surface type based on normal
                        const normal = this.classifySurface(hit);
                        
                        // Add to detected surfaces if it's a room surface
                        if (normal && !this.isDuplicateSurface(pose.transform.position, normal)) {
                            this.detectedSurfaces.push({
                                position: pose.transform.position,
                                normal: normal,
                                type: this.getSurfaceType(normal),
                                timestamp: time
                            });
                            
                            // Visualize detected surface
                            this.visualizeSurface(pose.transform.position, normal, this.getSurfaceType(normal));
                        }
                    }
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }

            handleTap(event) {
                if (!this.xrSession || !this.hitTestSource) return;
                
                // Get tap position in normalized device coordinates
                const rect = this.renderer.domElement.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // TODO: Implement raycasting for manual point selection
                // This would require more complex hit testing
                this.updateStatus('Manual point selection is not fully implemented in this demo');
            }

            capturePoint() {
                if (!this.xrSession || !this.renderer.xr.getSession()) {
                    this.updateStatus('Start AR session first');
                    return;
                }
                
                this.updateStatus('Surface capture triggered');
            }

            classifySurface(hit) {
                // This is a simplified classification
                // In a real app, you'd use more sophisticated algorithms
                const pose = hit.getPose(this.xrReferenceSpace);
                if (!pose) return null;
                
                // Extract normal from hit result (simplified)
                // Note: Actual hit test results don't provide normals in basic WebXR
                // This is a placeholder for demonstration
                const position = pose.transform.position;
                
                // Simulate classification based on position
                const threshold = 0.2;
                
                if (Math.abs(position.y) < threshold) {
                    return { x: 0, y: 1, z: 0 }; // Floor
                } else if (Math.abs(position.y - 2) < threshold) {
                    return { x: 0, y: -1, z: 0 }; // Ceiling
                } else {
                    // Wall - classify based on dominant axis
                    const absX = Math.abs(position.x);
                    const absZ = Math.abs(position.z);
                    
                    if (absX > absZ) {
                        return { x: position.x > 0 ? -1 : 1, y: 0, z: 0 };
                    } else {
                        return { x: 0, y: 0, z: position.z > 0 ? -1 : 1 };
                    }
                }
            }

            getSurfaceType(normal) {
                if (normal.y > 0.5) return 'floor';
                if (normal.y < -0.5) return 'ceiling';
                return 'wall';
            }

            isDuplicateSurface(position, normal, threshold = 0.3) {
                return this.detectedSurfaces.some(surface => {
                    const posDiff = Math.sqrt(
                        Math.pow(surface.position.x - position.x, 2) +
                        Math.pow(surface.position.y - position.y, 2) +
                        Math.pow(surface.position.z - position.z, 2)
                    );
                    
                    const normalDiff = Math.sqrt(
                        Math.pow(surface.normal.x - normal.x, 2) +
                        Math.pow(surface.normal.y - normal.y, 2) +
                        Math.pow(surface.normal.z - normal.z, 2)
                    );
                    
                    return posDiff < threshold && normalDiff < 0.5;
                });
            }

            visualizeSurface(position, normal, type) {
                const colors = {
                    floor: 0x4CAF50,    // Green
                    wall: 0x2196F3,     // Blue
                    ceiling: 0xFF9800   // Orange
                };
                
                // Create a small plane to visualize surface
                const geometry = new THREE.PlaneGeometry(0.1, 0.1);
                const material = new THREE.MeshBasicMaterial({ 
                    color: colors[type] || 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                
                const plane = new THREE.Mesh(geometry, material);
                plane.position.set(position.x, position.y, position.z);
                
                // Orient plane based on normal
                plane.lookAt(
                    position.x + normal.x,
                    position.y + normal.y,
                    position.z + normal.z
                );
                
                this.scene.add(plane);
            }

            async processRoomLayout() {
                this.showLoading('Processing room layout...');
                
                // Simulate processing delay
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Group surfaces into room boundaries
                const boundaries = this.groupSurfacesIntoBoundaries();
                
                // Calculate room dimensions
                const dimensions = this.calculateRoomDimensions(boundaries);
                
                // Generate JSON output
                this.roomLayout = this.generateRoomJSON(boundaries, dimensions);
                
                // Display results
                this.displayResults();
                
                this.hideLoading();
                this.updateStatus('Room layout processed successfully');
            }

            groupSurfacesIntoBoundaries() {
                // Simple grouping algorithm
                const boundaries = {
                    walls: [],
                    floor: null,
                    ceiling: null
                };
                
                // Group by type
                const walls = this.detectedSurfaces.filter(s => s.type === 'wall');
                const floors = this.detectedSurfaces.filter(s => s.type === 'floor');
                const ceilings = this.detectedSurfaces.filter(s => s.type === 'ceiling');
                
                // For demo purposes, create simplified boundaries
                if (floors.length > 0) {
                    boundaries.floor = {
                        vertices: this.calculateBoundaryVertices(floors),
                        material: 'concrete',
                        thickness: 0.2
                    };
                }
                
                if (ceilings.length > 0) {
                    boundaries.ceiling = {
                        vertices: this.calculateBoundaryVertices(ceilings),
                        material: 'drywall',
                        thickness: 0.15
                    };
                }
                
                // Group walls into distinct planes
                const wallGroups = this.groupByOrientation(walls);
                wallGroups.forEach((group, index) => {
                    boundaries.walls.push({
                        id: `wall_${index + 1}`,
                        vertices: this.calculateBoundaryVertices(group.surfaces),
                        orientation: group.orientation,
                        material: 'drywall',
                        thickness: 0.1,
                        openings: []
                    });
                });
                
                return boundaries;
            }

            calculateBoundaryVertices(surfaces) {
                if (surfaces.length === 0) return [];
                
                // Find min and max positions
                const positions = surfaces.map(s => s.position);
                const minX = Math.min(...positions.map(p => p.x));
                const maxX = Math.max(...positions.map(p => p.x));
                const minY = Math.min(...positions.map(p => p.y));
                const maxY = Math.max(...positions.map(p => p.y));
                const minZ = Math.min(...positions.map(p => p.z));
                const maxZ = Math.max(...positions.map(p => p.z));
                
                // Create rectangular boundary (simplified)
                return [
                    [minX, minY, minZ],
                    [maxX, minY, minZ],
                    [maxX, maxY, maxZ],
                    [minX, maxY, minZ]
                ];
            }

            groupByOrientation(surfaces) {
                const groups = [];
                
                surfaces.forEach(surface => {
                    const orientation = this.getOrientation(surface.normal);
                    let group = groups.find(g => g.orientation === orientation);
                    
                    if (!group) {
                        group = { orientation, surfaces: [] };
                        groups.push(group);
                    }
                    
                    group.surfaces.push(surface);
                });
                
                return groups;
            }

            getOrientation(normal) {
                if (Math.abs(normal.x) > 0.5) {
                    return normal.x > 0 ? 'east' : 'west';
                } else if (Math.abs(normal.z) > 0.5) {
                    return normal.z > 0 ? 'south' : 'north';
                }
                return 'unknown';
            }

            calculateRoomDimensions(boundaries) {
                if (!boundaries.floor || boundaries.walls.length === 0) {
                    return { width: 0, depth: 0, height: 0, area: 0, volume: 0 };
                }
                
                const floorVerts = boundaries.floor.vertices;
                const minX = Math.min(...floorVerts.map(v => v[0]));
                const maxX = Math.max(...floorVerts.map(v => v[0]));
                const minZ = Math.min(...floorVerts.map(v => v[2]));
                const maxZ = Math.max(...floorVerts.map(v => v[2]));
                
                const width = Math.abs(maxX - minX);
                const depth = Math.abs(maxZ - minZ);
                const height = 2.5; // Default height
                
                return {
                    width: parseFloat(width.toFixed(2)),
                    depth: parseFloat(depth.toFixed(2)),
                    height: parseFloat(height.toFixed(2)),
                    area: parseFloat((width * depth).toFixed(2)),
                    volume: parseFloat((width * depth * height).toFixed(2))
                };
            }

            generateRoomJSON(boundaries, dimensions) {
                const roomData = {
                    metadata: {
                        version: "1.0",
                        type: "empty_room_layout",
                        timestamp: new Date().toISOString(),
                        scannedWith: "WebXR Room Scanner",
                        unit: "meters"
                    },
                    boundaries: boundaries,
                    dimensions: dimensions,
                    openings: {
                        doors: [],
                        windows: []
                    },
                    furnitureRemoved: true,
                    processing: {
                        surfacesDetected: this.detectedSurfaces.length,
                        wallsDetected: boundaries.walls.length,
                        confidence: parseFloat((Math.min(1, this.detectedSurfaces.length / 50)).toFixed(2))
                    }
                };
                
                return roomData;
            }

            displayResults() {
                const jsonOutput = document.getElementById('json-output');
                jsonOutput.textContent = JSON.stringify(this.roomLayout, null, 2);
                document.getElementById('results').style.display = 'block';
            }

            exportJSON() {
                if (!this.roomLayout) {
                    this.updateStatus('No room layout to export');
                    return;
                }
                
                const jsonString = JSON.stringify(this.roomLayout, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `room_layout_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateStatus('Room layout exported as JSON');
            }

            resetScan() {
                this.scanPoints = [];
                this.detectedSurfaces = [];
                this.roomLayout = null;
                
                // Remove all visualized surfaces
                this.scene.children = this.scene.children.filter(child => 
                    child.type !== 'Mesh' || child.geometry.type !== 'PlaneGeometry'
                );
                
                this.updateStatus('Scan reset. Ready for new scan.');
            }

            onSessionEnd() {
                this.xrSession = null;
                this.hitTestSource = null;
                this.isScanning = false;
                
                document.getElementById('ui-container').style.display = 'none';
                document.getElementById('xr-button').style.display = 'block';
                document.getElementById('status').style.display = 'none';
                
                this.updateStatus('AR session ended');
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            updateStatus(message) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                console.log('Status:', message);
            }

            showError(message) {
                alert('Error: ' + message);
                console.error(message);
            }

            showLoading(message) {
                document.getElementById('loading-text').textContent = message;
                document.getElementById('loading').style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Initialize the scanner when page loads
        window.addEventListener('load', () => {
            window.scanner = new RoomScanner();
            
            // Check for mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobile) {
                document.getElementById('instructions').innerHTML += 
                    '<p style="color: #ff9800; margin-top: 10px;">Note: This app works best on mobile devices with AR capabilities.</p>';
            }
        });

        // Handle page visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && window.scanner && window.scanner.xrSession) {
                window.scanner.xrSession.end();
            }
        });
    </script>
</body>
</html>
