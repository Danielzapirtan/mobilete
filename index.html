<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scanner Dispunere Cameră WebXR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        #xr-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }

        #xr-button:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #ui-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            display: none;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            opacity: 0.8;
        }

        select, button {
            width: 200px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #444;
            background: #333;
            color: white;
        }

        button {
            background: #4CAF50;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #45a049;
        }

        #status {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            display: none;
            z-index: 99;
        }

        #results {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 100;
        }

        #results h3 {
            margin-bottom: 15px;
            color: #4CAF50;
        }

        #json-output {
            background: #222;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
        }

        #export-btn {
            margin-top: 10px;
            width: 100%;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .scan-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4CAF50;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }

        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            max-width: 500px;
            padding: 30px;
            background: rgba(0,0,0,0.9);
            border-radius: 15px;
            display: block;
            z-index: 101;
        }

        #instructions h2 {
            margin-bottom: 20px;
            color: #4CAF50;
        }

        #instructions p {
            margin-bottom: 15px;
            line-height: 1.5;
        }

        #instructions ol {
            text-align: left;
            margin: 20px;
            line-height: 1.8;
        }

        #start-btn {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Instrucțiuni -->
    <div id="instructions">
        <h2>Scanner Cameră WebXR</h2>
        <p>Scanează-ți camera și exportă planul ca JSON.</p>
        <p><strong>Cerințe:</strong></p>
        <ol>
            <li>Smartphone modern cu capabilități AR</li>
            <li>Browser Chrome sau Safari</li>
            <li>Condiții de iluminat bune</li>
            <li>Deplasează-te lent în jurul camerei</li>
        </ol>
        <p><em>Aplicația va detecta pereții, podeaua și tavanul, apoi va elimina automat mobila.</em></p>
        <button id="start-btn">Începe Scanarea</button>
    </div>

    <!-- Interfața Principală -->
    <div id="ui-container">
        <div class="control-group">
            <label>Mod Scanare:</label>
            <select id="scan-mode">
                <option value="auto">Detectare Automată Suprafețe</option>
                <option value="manual">Selecție Manuală Puncte</option>
            </select>
        </div>
        <div class="control-group">
            <button id="capture-btn">Capturează Punct Suprafață</button>
        </div>
        <div class="control-group">
            <button id="process-btn">Procesează Planul Camerei</button>
        </div>
        <div class="control-group">
            <button id="reset-btn">Resetează Scanarea</button>
        </div>
    </div>

    <!-- Afișaj Stare -->
    <div id="status">Gata de scanare...</div>

    <!-- Panou Rezultate -->
    <div id="results">
        <h3>Plan Cameră JSON</h3>
        <div id="json-output"></div>
        <button id="export-btn">Exportă Fișier JSON</button>
        <button id="close-results">Închide</button>
    </div>

    <!-- Indicator Încărcare -->
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Se procesează...</div>
    </div>

    <!-- Container Canvas -->
    <div id="canvas-container"></div>

    <!-- Buton XR -->
    <button id="xr-button">Intră în Mod AR</button>

    <!-- Biblioteci Three.js și WebXR -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        class RoomScanner {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.xrSession = null;
                this.xrReferenceSpace = null;
                this.hitTestSource = null;
                
                this.scanPoints = [];
                this.detectedSurfaces = [];
                this.roomLayout = null;
                
                this.isScanning = false;
                this.scanMode = 'auto';
                
                this.init();
            }

            async init() {
                // Verifică suportul WebXR
                if (!navigator.xr) {
                    this.showError('WebXR nu este suportat în acest browser. Încearcă Chrome pe Android sau Safari pe iOS.');
                    return;
                }

                // Inițializează Three.js
                this.setupThreeJS();
                
                // Configurează ascultătorii de evenimente
                this.setupEventListeners();
                
                // Verifică disponibilitatea AR
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    this.showError('AR nu este suportat pe acest dispozitiv.');
                    return;
                }

                document.getElementById('xr-button').style.display = 'block';
                this.updateStatus('Gata să începem scanarea AR');
            }

            setupThreeJS() {
                // Creează scena
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                
                // Creează camera
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Creează renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.xr.enabled = true;
                
                // Adaugă canvas în container
                const container = document.getElementById('canvas-container');
                container.appendChild(this.renderer.domElement);
                
                // Adaugă iluminare
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 1, 0);
                this.scene.add(directionalLight);
                
                // Adaugă grilă helper
                const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
                gridHelper.position.y = -1;
                this.scene.add(gridHelper);
            }

            setupEventListeners() {
                // Controale UI
                document.getElementById('start-btn').addEventListener('click', () => {
                    document.getElementById('instructions').classList.add('hidden');
                    this.startXR();
                });
                
                document.getElementById('xr-button').addEventListener('click', () => this.startXR());
                document.getElementById('capture-btn').addEventListener('click', () => this.capturePoint());
                document.getElementById('process-btn').addEventListener('click', () => this.processRoomLayout());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetScan());
                document.getElementById('export-btn').addEventListener('click', () => this.exportJSON());
                document.getElementById('close-results').addEventListener('click', () => {
                    document.getElementById('results').style.display = 'none';
                });
                
                document.getElementById('scan-mode').addEventListener('change', (e) => {
                    this.scanMode = e.target.value;
                });
                
                // Gestionează redimensionarea ferestrei
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Gestionează tap pentru capturare puncte în AR
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (this.xrSession && this.scanMode === 'manual') {
                        this.handleTap(e);
                    }
                });
            }

            async startXR() {
                try {
                    // Solicită sesiunea AR
                    this.xrSession = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['hit-test', 'local'],
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.body }
                    });
                    
                    // Configurează sesiunea XR
                    this.renderer.xr.setSession(this.xrSession);
                    
                    // Creează spațiu de referință
                    this.xrReferenceSpace = await this.xrSession.requestReferenceSpace('local');
                    
                    // Inițializează sursa de hit test
                    const viewerSpace = await this.xrSession.requestReferenceSpace('viewer');
                    this.hitTestSource = await this.xrSession.requestHitTestSource({ 
                        space: viewerSpace 
                    });
                    
                    // Configurează UI pentru scanare
                    document.getElementById('ui-container').style.display = 'block';
                    document.getElementById('xr-button').style.display = 'none';
                    document.getElementById('status').style.display = 'block';
                    
                    this.isScanning = true;
                    this.updateStatus('Scanarea a început. Mișcă telefonul în jurul camerei.');
                    
                    // Începe bucla de animație
                    this.renderer.setAnimationLoop((time, frame) => this.renderScene(time, frame));
                    
                    // Gestionează sfârșitul sesiunii
                    this.xrSession.addEventListener('end', () => this.onSessionEnd());
                    
                } catch (error) {
                    console.error('Nu s-a putut porni sesiunea AR:', error);
                    this.showError('Nu s-a putut porni AR: ' + error.message);
                }
            }

            async renderScene(time, frame) {
                if (!this.xrSession) return;
                
                // Obține cadrul XR
                const session = this.renderer.xr.getSession();
                const referenceSpace = this.renderer.xr.getReferenceSpace();
                
                if (frame && this.hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                    
                    if (hitTestResults.length > 0 && this.scanMode === 'auto') {
                        // Detectare automată suprafețe
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        
                        // Clasifică tipul suprafeței pe baza normalei
                        const normal = this.classifySurface(hit);
                        
                        // Adaugă la suprafețele detectate dacă este o suprafață a camerei
                        if (normal && !this.isDuplicateSurface(pose.transform.position, normal)) {
                            this.detectedSurfaces.push({
                                position: pose.transform.position,
                                normal: normal,
                                type: this.getSurfaceType(normal),
                                timestamp: time
                            });
                            
                            // Vizualizează suprafața detectată
                            this.visualizeSurface(pose.transform.position, normal, this.getSurfaceType(normal));
                        }
                    }
                }
                
                // Redă scena
                this.renderer.render(this.scene, this.camera);
            }

            handleTap(event) {
                if (!this.xrSession || !this.hitTestSource) return;
                
                // Obține poziția tap-ului în coordonate normalizate de dispozitiv
                const rect = this.renderer.domElement.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // TODO: Implementează raycasting pentru selecția manuală de puncte
                // Acest lucru ar necesita un hit test mai complex
                this.updateStatus('Selecția manuală de puncte nu este complet implementată în acest demo');
            }

            capturePoint() {
                if (!this.xrSession || !this.renderer.xr.getSession()) {
                    this.updateStatus('Pornește mai întâi sesiunea AR');
                    return;
                }
                
                this.updateStatus('Capturare suprafață declanșată');
            }

            classifySurface(hit) {
                // Aceasta este o clasificare simplificată
                // Într-o aplicație reală, ai folosi algoritmi mai sofisticați
                const pose = hit.getPose(this.xrReferenceSpace);
                if (!pose) return null;
                
                // Extrage normala din rezultatul hit (simplificat)
                // Notă: Rezultatele reale de hit test nu furnizează normale în WebXR de bază
                // Aceasta este un substituent pentru demonstrație
                const position = pose.transform.position;
                
                // Simulează clasificarea pe baza poziției
                const threshold = 0.2;
                
                if (Math.abs(position.y) < threshold) {
                    return { x: 0, y: 1, z: 0 }; // Podea
                } else if (Math.abs(position.y - 2) < threshold) {
                    return { x: 0, y: -1, z: 0 }; // Tavan
                } else {
                    // Perete - clasifică pe baza axei dominante
                    const absX = Math.abs(position.x);
                    const absZ = Math.abs(position.z);
                    
                    if (absX > absZ) {
                        return { x: position.x > 0 ? -1 : 1, y: 0, z: 0 };
                    } else {
                        return { x: 0, y: 0, z: position.z > 0 ? -1 : 1 };
                    }
                }
            }

            getSurfaceType(normal) {
                if (normal.y > 0.5) return 'floor';
                if (normal.y < -0.5) return 'ceiling';
                return 'wall';
            }

            isDuplicateSurface(position, normal, threshold = 0.3) {
                return this.detectedSurfaces.some(surface => {
                    const posDiff = Math.sqrt(
                        Math.pow(surface.position.x - position.x, 2) +
                        Math.pow(surface.position.y - position.y, 2) +
                        Math.pow(surface.position.z - position.z, 2)
                    );
                    
                    const normalDiff = Math.sqrt(
                        Math.pow(surface.normal.x - normal.x, 2) +
                        Math.pow(surface.normal.y - normal.y, 2) +
                        Math.pow(surface.normal.z - normal.z, 2)
                    );
                    
                    return posDiff < threshold && normalDiff < 0.5;
                });
            }

            visualizeSurface(position, normal, type) {
                const colors = {
                    floor: 0x4CAF50,    // Verde
                    wall: 0x2196F3,     // Albastru
                    ceiling: 0xFF9800   // Portocaliu
                };
                
                // Creează un plan mic pentru a vizualiza suprafața
                const geometry = new THREE.PlaneGeometry(0.1, 0.1);
                const material = new THREE.MeshBasicMaterial({ 
                    color: colors[type] || 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                
                const plane = new THREE.Mesh(geometry, material);
                plane.position.set(position.x, position.y, position.z);
                
                // Orientă planul pe baza normalei
                plane.lookAt(
                    position.x + normal.x,
                    position.y + normal.y,
                    position.z + normal.z
                );
                
                this.scene.add(plane);
            }

            async processRoomLayout() {
                this.showLoading('Se procesează planul camerei...');
                
                // Simulează întârzierea procesării
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Grupează suprafețele în limitele camerei
                const boundaries = this.groupSurfacesIntoBoundaries();
                
                // Calculează dimensiunile camerei
                const dimensions = this.calculateRoomDimensions(boundaries);
                
                // Generează ieșirea JSON
                this.roomLayout = this.generateRoomJSON(boundaries, dimensions);
                
                // Afișează rezultatele
                this.displayResults();
                
                this.hideLoading();
                this.updateStatus('Planul camerei a fost procesat cu succes');
            }

            groupSurfacesIntoBoundaries() {
                // Algoritm simplu de grupare
                const boundaries = {
                    walls: [],
                    floor: null,
                    ceiling: null
                };
                
                // Grupează după tip
                const walls = this.detectedSurfaces.filter(s => s.type === 'wall');
                const floors = this.detectedSurfaces.filter(s => s.type === 'floor');
                const ceilings = this.detectedSurfaces.filter(s => s.type === 'ceiling');
                
                // Pentru scopuri demo, creează limite simplificate
                if (floors.length > 0) {
                    boundaries.floor = {
                        vertices: this.calculateBoundaryVertices(floors),
                        material: 'beton',
                        thickness: 0.2
                    };
                }
                
                if (ceilings.length > 0) {
                    boundaries.ceiling = {
                        vertices: this.calculateBoundaryVertices(ceilings),
                        material: 'gips-carton',
                        thickness: 0.15
                    };
                }
                
                // Grupează pereții în planuri distincte
                const wallGroups = this.groupByOrientation(walls);
                wallGroups.forEach((group, index) => {
                    boundaries.walls.push({
                        id: `wall_${index + 1}`,
                        vertices: this.calculateBoundaryVertices(group.surfaces),
                        orientation: group.orientation,
                        material: 'gips-carton',
                        thickness: 0.1,
                        openings: []
                    });
                });
                
                return boundaries;
            }

            calculateBoundaryVertices(surfaces) {
                if (surfaces.length === 0) return [];
                
                // Găsește pozițiile min și max
                const positions = surfaces.map(s => s.position);
                const minX = Math.min(...positions.map(p => p.x));
                const maxX = Math.max(...positions.map(p => p.x));
                const minY = Math.min(...positions.map(p => p.y));
                const maxY = Math.max(...positions.map(p => p.y));
                const minZ = Math.min(...positions.map(p => p.z));
                const maxZ = Math.max(...positions.map(p => p.z));
                
                // Creează limită rectangulară (simplificată)
                return [
                    [minX, minY, minZ],
                    [maxX, minY, minZ],
                    [maxX, maxY, maxZ],
                    [minX, maxY, minZ]
                ];
            }

            groupByOrientation(surfaces) {
                const groups = [];
                
                surfaces.forEach(surface => {
                    const orientation = this.getOrientation(surface.normal);
                    let group = groups.find(g => g.orientation === orientation);
                    
                    if (!group) {
                        group = { orientation, surfaces: [] };
                        groups.push(group);
                    }
                    
                    group.surfaces.push(surface);
                });
                
                return groups;
            }

            getOrientation(normal) {
                if (Math.abs(normal.x) > 0.5) {
                    return normal.x > 0 ? 'east' : 'west';
                } else if (Math.abs(normal.z) > 0.5) {
                    return normal.z > 0 ? 'south' : 'north';
                }
                return 'unknown';
            }

            calculateRoomDimensions(boundaries) {
                if (!boundaries.floor || boundaries.walls.length === 0) {
                    return { width: 0, depth: 0, height: 0, area: 0, volume: 0 };
                }
                
                const floorVerts = boundaries.floor.vertices;
                const minX = Math.min(...floorVerts.map(v => v[0]));
                const maxX = Math.max(...floorVerts.map(v => v[0]));
                const minZ = Math.min(...floorVerts.map(v => v[2]));
                const maxZ = Math.max(...floorVerts.map(v => v[2]));
                
                const width = Math.abs(maxX - minX);
                const depth = Math.abs(maxZ - minZ);
                const height = 2.5; // Înălțime implicită
                
                return {
                    width: parseFloat(width.toFixed(2)),
                    depth: parseFloat(depth.toFixed(2)),
                    height: parseFloat(height.toFixed(2)),
                    area: parseFloat((width * depth).toFixed(2)),
                    volume: parseFloat((width * depth * height).toFixed(2))
                };
            }

            generateRoomJSON(boundaries, dimensions) {
                const roomData = {
                    metadata: {
                        version: "1.0",
                        type: "empty_room_layout",
                        timestamp: new Date().toISOString(),
                        scannedWith: "Scanner Cameră WebXR",
                        unit: "meters"
                    },
                    boundaries: boundaries,
                    dimensions: dimensions,
                    openings: {
                        doors: [],
                        windows: []
                    },
                    furnitureRemoved: true,
                    processing: {
                        surfacesDetected: this.detectedSurfaces.length,
                        wallsDetected: boundaries.walls.length,
                        confidence: parseFloat((Math.min(1, this.detectedSurfaces.length / 50)).toFixed(2))
                    }
                };
                
                return roomData;
            }

            displayResults() {
                const jsonOutput = document.getElementById('json-output');
                jsonOutput.textContent = JSON.stringify(this.roomLayout, null, 2);
                document.getElementById('results').style.display = 'block';
            }

            exportJSON() {
                if (!this.roomLayout) {
                    this.updateStatus('Nu există plan de cameră de exportat');
                    return;
                }
                
                const jsonString = JSON.stringify(this.roomLayout, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `plan_camera_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateStatus('Planul camerei a fost exportat ca JSON');
            }

            resetScan() {
                this.scanPoints = [];
                this.detectedSurfaces = [];
                this.roomLayout = null;
                
                // Îndepărtează toate suprafețele vizualizate
                this.scene.children = this.scene.children.filter(child => 
                    child.type !== 'Mesh' || child.geometry.type !== 'PlaneGeometry'
                );
                
                this.updateStatus('Scanare resetată. Gata pentru o scanare nouă.');
            }

            onSessionEnd() {
                this.xrSession = null;
                this.hitTestSource = null;
                this.isScanning = false;
                
                document.getElementById('ui-container').style.display = 'none';
                document.getElementById('xr-button').style.display = 'block';
                document.getElementById('status').style.display = 'none';
                
                this.updateStatus('Sesiunea AR s-a încheiat');
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            updateStatus(message) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                console.log('Stare:', message);
            }

            showError(message) {
                alert('Eroare: ' + message);
                console.error(message);
            }

            showLoading(message) {
                document.getElementById('loading-text').textContent = message;
                document.getElementById('loading').style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Inițializează scannerul când se încarcă pagina
        window.addEventListener('load', () => {
            window.scanner = new RoomScanner();
            
            // Verifică dacă este dispozitiv mobil
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobile) {
                document.getElementById('instructions').innerHTML += 
                    '<p style="color: #ff9800; margin-top: 10px;">Notă: Această aplicație funcționează cel mai bine pe dispozitive mobile cu capabilități AR.</p>';
            }
        });

        // Gestionează schimbarea vizibilității paginii
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && window.scanner && window.scanner.xrSession) {
                window.scanner.xrSession.end();
            }
        });
    </script>
</body>
</html>